<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>シンプル辞書</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
        }
        /* モーダルのオーバーレイ */
        .modal-overlay {
            background-color: rgba(0, 0, 0, 0.6);
        }
        /* ボタンのアクティブ状態 */
        .btn-active {
            @apply bg-blue-600 text-white;
        }
        .btn-inactive {
            @apply bg-gray-300 text-gray-800;
        }
        .loading-animation {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #ffffff;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
        .word-font {
            font-family: var(--word-font, 'Inter', sans-serif);
            font-size: 1.25em; /* Tailwindのtext-xlに相当 */
            font-weight: 600; /* Tailwindのfont-semiboldに相当 */
        }
    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">
    <!-- リスト表示エリア -->
    <div id="listView" class="bg-white p-6 rounded-lg shadow-xl w-full max-w-2xl">
        <h1 class="text-3xl font-bold text-gray-800 mb-6 text-center">シンプル辞書</h1>
        
        <!-- 単語入力フォーム -->
        <div class="mb-6 space-y-4">
            <div>
                <label for="wordIdInput" class="block text-gray-700 text-sm font-bold mb-2">単語識別番号 (未入力で自動採番):</label>
                <input type="number" id="wordIdInput" placeholder="例: 101"
                       class="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">
            </div>
            <div>
                <label for="wordInput" class="block text-gray-700 text-sm font-bold mb-2">単語:</label>
                <input type="text" id="wordInput" placeholder="例: こんにちは"
                       class="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">
            </div>
            <div>
                <label for="partOfSpeechSelect" class="block text-gray-700 text-sm font-bold mb-2">品詞:</label>
                <select id="partOfSpeechSelect"
                        class="shadow border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <!-- Options will be populated by JavaScript -->
                </select>
                <div id="newPartOfSpeechContainer" class="mt-2 hidden">
                    <label for="newPartOfSpeechInput" class="block text-gray-700 text-sm font-bold mb-2">新しい品詞を入力:</label>
                    <input type="text" id="newPartOfSpeechInput" placeholder="例: 擬音語"
                           class="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
            </div>
            <div>
                <label for="meaningInput" class="block text-gray-700 text-sm font-bold mb-2">意味:</label>
                <textarea id="meaningInput" placeholder="例: あいさつに使われる言葉" rows="3"
                          class="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-y"></textarea>
            </div>
            <div>
                <label for="exampleInput" class="block text-gray-700 text-sm font-bold mb-2">例文 (各行が1つの例文):</label>
                <textarea id="exampleInput" placeholder="例: 彼は毎日日本語を勉強します。\n私は昨日、美味しい寿司を食べました。" rows="3"
                          class="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-y"></textarea>
            </div>
            <div>
                <label for="usageInput" class="block text-gray-700 text-sm font-bold mb-2">用法・詳細情報:</label>
                <textarea id="usageInput" placeholder="例: 日本語で最も一般的な挨拶の一つで、時間帯を問わず使える。" rows="3"
                          class="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-y"></textarea>
            </div>
            <button id="addWordButton"
                    class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:-translate-y-1 w-full focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                単語を追加
            </button>
        </div>

        <!-- 検索とフィルタのオプション -->
        <div class="mb-6 space-y-4 md:flex md:space-y-0 md:space-x-4">
            <div class="flex-grow">
                <label for="searchInput" class="block text-gray-700 text-sm font-bold mb-2">単語を検索:</label>
                <input type="text" id="searchInput" placeholder="単語を入力..."
                       class="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500">
            </div>
            <div class="flex-grow">
                <label for="partOfSpeechFilter" class="block text-gray-700 text-sm font-bold mb-2">品詞で絞り込み:</label>
                <select id="partOfSpeechFilter"
                        class="shadow border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <!-- Options will be populated by JavaScript -->
                </select>
            </div>
            <div class="flex-shrink-0 md:self-end">
                <button id="clearFiltersButton"
                        class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:-translate-y-1 w-full md:w-auto focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-opacity-50">
                    フィルターをクリア
                </button>
            </div>
        </div>

        <!-- ソートオプション -->
        <div class="mb-6">
            <label for="sortOption" class="block text-gray-700 text-sm font-bold mb-2">並び替え:</label>
            <select id="sortOption"
                    class="shadow border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500">
                <option value="timestamp_desc">追加順（新しい順）</option>
                <option value="timestamp_asc">追加順（古い順）</option>
                <option value="wordId_asc">識別番号順（昇順）</option>
                <option value="wordId_desc">識別番号順（降順）</option>
                <option value="word_asc">単語の文字順（昇順）</option>
                <option value="word_desc">単語の文字順（降順）</option>
            </select>
        </div>

        <!-- 表示切り替えオプション -->
        <div class="mb-6">
            <label class="block text-gray-700 text-sm font-bold mb-2">表示形式:</label>
            <div class="flex space-x-2">
                <button id="viewModeLarge"
                        class="flex-1 font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:-translate-y-0.5 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 btn-active">
                    通常表示
                </button>
                <button id="viewModeSmall"
                        class="flex-1 font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:-translate-y-0.5 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-opacity-50 btn-inactive">
                    コンパクト表示
                </button>
            </div>
        </div>

        <!-- フォントインポート -->
        <div class="mb-6">
            <label for="fontFile" class="inline-flex items-center justify-center bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg shadow-md cursor-pointer transition duration-300 ease-in-out transform hover:-translate-y-1 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50">
                フォントをインポート (.ttf, .otf, .woff, .woff2)
                <input type="file" id="fontFile" class="hidden" accept=".ttf,.otf,.woff,.woff2">
            </label>
        </div>

        <!-- インポート/エクスポートオプション -->
        <div class="mb-6 flex flex-col sm:flex-row space-y-3 sm:space-y-0 sm:space-x-4 justify-center">
            <button id="exportButton"
                    class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:-translate-y-1 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50">
                辞書をエクスポート
            </button>
            <label for="importFile" class="inline-flex items-center justify-center bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg shadow-md cursor-pointer transition duration-300 ease-in-out transform hover:-translate-y-1 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-50">
                辞書をインポート
                <input type="file" id="importFile" class="hidden" accept=".txt,.csv">
            </label>
        </div>

        <!-- 単語リスト表示エリア -->
        <h2 class="text-2xl font-bold text-gray-800 mb-4">登録単語リスト</h2>
        <div id="wordList" class="space-y-4">
            <p id="loadingMessage" class="text-center text-gray-500">単語を読み込み中...</p>
        </div>
    </div>

    <!-- 単語詳細表示エリア -->
    <div id="detailView" class="hidden bg-white p-6 rounded-lg shadow-xl w-full max-w-2xl">
        <h2 class="text-2xl font-bold text-gray-800 mb-4" id="detailWordTitle"></h2>
        <p class="text-sm text-gray-600 mb-4">
            単語識別番号: <span id="detailWordId" class="font-semibold text-blue-600"></span>
        </p>
        <p class="text-gray-700 mb-2">
            <span class="font-semibold">品詞:</span> <span id="detailPartOfSpeech"></span>
        </p>
        <div class="mb-6">
            <p class="font-semibold text-gray-700 mb-1">意味:</p>
            <p id="detailMeaning" class="text-gray-700 whitespace-pre-wrap bg-gray-50 p-3 rounded-lg border border-gray-200"></p>
        </div>
        <div class="mb-6">
            <p class="font-semibold text-gray-700 mb-1">例文:</p>
            <div id="detailExamples" class="text-gray-700 whitespace-pre-wrap bg-gray-50 p-3 rounded-lg border border-gray-200"></div>
        </div>
        <div class="mb-6">
            <p class="font-semibold text-gray-700 mb-1">用法・詳細情報:</p>
            <p id="detailUsage" class="text-gray-700 whitespace-pre-wrap bg-gray-50 p-3 rounded-lg border border-gray-200"></p>
        </div>
        <div class="mb-6">
            <p class="font-semibold text-gray-700 mb-1">関連語:</p>
            <div id="detailSynonyms" class="text-gray-700 whitespace-pre-wrap bg-gray-50 p-3 rounded-lg border border-gray-200"></div>
        </div>

        <!--<div class="flex flex-wrap gap-4 mb-6">
            <button id="generateSynonymsButton" class="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:-translate-y-0.5 flex-1 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50">
                ✨ 類義語を生成
            </button>
            <button id="generateExamplesButton" class="bg-teal-500 hover:bg-teal-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:-translate-y-0.5 flex-1 focus:outline-none focus:ring-2 focus:ring-teal-500 focus:ring-opacity-50">
                ✨ 例文を生成
            </button>
            <button id="generateUsageButton" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:-translate-y-0.5 flex-1 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-50">
                ✨ 用法・詳細情報を生成
            </button>
        </div>-->

        <div class="flex justify-end space-x-4">
            <button id="detailEditButton" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:-translate-y-0.5">編集</button>
            <button id="detailDeleteButton" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:-translate-y-0.5">削除</button>
            <button id="backToListButton" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:-translate-y-0.5">リストに戻る</button>
        </div>
    </div>

    <!-- インポート選択モーダル -->
    <div id="importOptionsModal" class="fixed inset-0 hidden modal-overlay flex items-center justify-center p-4 z-50">
        <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-md text-center">
            <h3 class="text-xl font-bold text-gray-800 mb-6">インポート方法を選択してください</h3>
            <div class="flex flex-col space-y-4">
                <button id="importNewButton"
                        class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:-translate-y-1 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                    新しい辞書として開く (既存の辞書は削除されます)
                </button>
                <button id="importAppendButton"
                        class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:-translate-y-1 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50">
                    現在の辞書に追加する (重複はスキップされます)
                </button>
                <button id="cancelImportButton"
                        class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:-translate-y-1 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-opacity-50">
                    キャンセル
                </button>
            </div>
        </div>
    </div>

    <!-- ロード中インジケーターモーダル -->
    <div id="loadingModal" class="fixed inset-0 hidden modal-overlay flex items-center justify-center p-4 z-50">
        <div class="bg-white p-8 rounded-lg shadow-xl text-center flex flex-col items-center">
            <div class="loading-animation mb-4"></div>
            <p class="text-lg font-semibold text-gray-800">生成中...</p>
            <p class="text-sm text-gray-600 mt-2">数秒かかる場合があります。しばらくお待ちください。</p>
        </div>
    </div>

    <script>
        // DOM要素の取得
        const wordIdInput = document.getElementById('wordIdInput');
        const wordInput = document.getElementById('wordInput');
        const partOfSpeechSelect = document.getElementById('partOfSpeechSelect');
        const newPartOfSpeechContainer = document.getElementById('newPartOfSpeechContainer');
        const newPartOfSpeechInput = document.getElementById('newPartOfSpeechInput');
        const meaningInput = document.getElementById('meaningInput');
        const exampleInput = document.getElementById('exampleInput');
        const usageInput = document.getElementById('usageInput');
        const addWordButton = document.getElementById('addWordButton');
        const wordListDiv = document.getElementById('wordList');
        const loadingMessage = document.getElementById('loadingMessage');

        const searchInput = document.getElementById('searchInput');
        const partOfSpeechFilter = document.getElementById('partOfSpeechFilter');
        const clearFiltersButton = document.getElementById('clearFiltersButton');

        const sortOption = document.getElementById('sortOption');

        const viewModeLargeButton = document.getElementById('viewModeLarge');
        const viewModeSmallButton = document.getElementById('viewModeSmall');
        let displayMode = 'large';

        const exportButton = document.getElementById('exportButton');
        const importFile = document.getElementById('importFile');
        const importOptionsModal = document.getElementById('importOptionsModal');
        const importNewButton = document.getElementById('importNewButton');
        const importAppendButton = document.getElementById('importAppendButton');
        const cancelImportButton = document.getElementById('cancelImportButton');
        const loadingModal = document.getElementById('loadingModal');
        
        // フォントインポート関連
        const fontFile = document.getElementById('fontFile');
        let importedFontName = null;

        // 詳細表示関連の要素
        const listView = document.getElementById('listView');
        const detailView = document.getElementById('detailView');
        const detailWordTitle = document.getElementById('detailWordTitle');
        const detailWordId = document.getElementById('detailWordId');
        const detailPartOfSpeech = document.getElementById('detailPartOfSpeech');
        const detailMeaning = document.getElementById('detailMeaning');
        const detailExamples = document.getElementById('detailExamples');
        const detailUsage = document.getElementById('detailUsage');
        const detailSynonyms = document.getElementById('detailSynonyms');
        const detailEditButton = document.getElementById('detailEditButton');
        const detailDeleteButton = document.getElementById('detailDeleteButton');
        const backToListButton = document.getElementById('backToListButton');
        /*
        // Gemini API 関連ボタン
        const generateSynonymsButton = document.getElementById('generateSynonymsButton');
        const generateExamplesButton = document.getElementById('generateExamplesButton');
        const generateUsageButton = document.getElementById('generateUsageButton');
        */
        // データの管理
        let dictionaryData = [];
        let customPartsOfSpeech = [];
        let allAvailablePartsOfSpeech = [];
        let importedFileContent = null;
        let currentWordDetailId = null;
        
        // 定義済み品詞リスト
        const predefinedPartsOfSpeech = [
            '名詞', '動詞', '形容詞', '副詞', '助詞', '助動詞', '感動詞', '連体詞', '接続詞'
        ];

        // データをlocalStorageに保存
        const saveData = () => {
            localStorage.setItem('dictionaryData', JSON.stringify(dictionaryData));
            localStorage.setItem('customPartsOfSpeech', JSON.stringify(customPartsOfSpeech));
        };

        // データをlocalStorageから読み込み
        const loadData = () => {
            const storedDictionary = localStorage.getItem('dictionaryData');
            const storedCustomPos = localStorage.getItem('customPartsOfSpeech');
            if (storedDictionary) {
                dictionaryData = JSON.parse(storedDictionary);
            } else {
                dictionaryData = [];
            }
            if (storedCustomPos) {
                customPartsOfSpeech = JSON.parse(storedCustomPos);
            } else {
                customPartsOfSpeech = [];
            }
            updateAllAvailablePartsOfSpeech();
            populatePartOfSpeechDropdowns();
            renderWords();
        };

        // 全ての利用可能な品詞リストを更新する
        const updateAllAvailablePartsOfSpeech = () => {
            const uniqueParts = new Set([...predefinedPartsOfSpeech, ...customPartsOfSpeech]);
            allAvailablePartsOfSpeech = Array.from(uniqueParts).sort();
        };

        // 品詞のドロップダウンを動的に更新する関数
        const populatePartOfSpeechDropdowns = (currentValueForNewWord = null, currentPartOfSpeechFilterValue = null) => {
            populateSelectElement(partOfSpeechSelect, allAvailablePartsOfSpeech, 'その他', currentValueForNewWord, false);
            populateSelectElement(partOfSpeechFilter, allAvailablePartsOfSpeech, 'すべて', currentPartOfSpeechFilterValue, true);
        };

        // 汎用的なセレクト要素の更新関数
        const populateSelectElement = (selectElement, options, otherOptionLabel, currentValue, includeAllOption) => {
            selectElement.innerHTML = '';

            if (includeAllOption) {
                selectElement.add(new Option(otherOptionLabel, 'すべて'));
            }

            if (!includeAllOption) {
                selectElement.add(new Option('選択してください', ''));
            }

            options.forEach(optionText => {
                if (optionText && optionText !== otherOptionLabel) {
                    selectElement.add(new Option(optionText, optionText));
                }
            });

            if (!includeAllOption || (includeAllOption && otherOptionLabel === 'その他')) {
                const otherOption = new Option(otherOptionLabel, otherOptionLabel);
                selectElement.add(otherOption);
            }

            if (currentValue) {
                if (Array.from(options).includes(currentValue)) {
                    selectElement.value = currentValue;
                } else {
                    selectElement.value = otherOptionLabel;
                    if (selectElement === partOfSpeechSelect) {
                        newPartOfSpeechContainer.classList.remove('hidden');
                        newPartOfSpeechInput.value = currentValue;
                    }
                }
            } else {
                if (!includeAllOption) {
                    selectElement.value = '';
                } else {
                    selectElement.value = 'すべて';
                }
            }
        };

        // 未使用の最小の単語IDを検索する関数
        const getNextAvailableWordId = () => {
            const existingIds = new Set(dictionaryData.map(word => word.wordId).filter(id => typeof id === 'number'));
            let nextId = 1;
            while (existingIds.has(nextId)) {
                nextId++;
            }
            return nextId;
        };
        
        // 単語を追加する関数
        const addWord = () => {
            let wordId = parseInt(wordIdInput.value.trim());
            const word = wordInput.value.trim();
            let partOfSpeech = partOfSpeechSelect.value;
            const meaning = meaningInput.value.trim();
            const examples = exampleInput.value.trim().split('\n').filter(line => line.trim() !== '');
            const usage = usageInput.value.trim();

            if (partOfSpeech === 'その他') {
                const newPos = newPartOfSpeechInput.value.trim();
                if (newPos === '') {
                    displayMessage("新しい品詞を入力してください！", "error");
                    return;
                }
                partOfSpeech = newPos;
                if (!customPartsOfSpeech.includes(newPos)) {
                    customPartsOfSpeech.push(newPos);
                    updateAllAvailablePartsOfSpeech();
                    populatePartOfSpeechDropdowns(newPos);
                }
            }

            if (word === '' || meaning === '' || partOfSpeech === '' || partOfSpeech === '選択してください') {
                displayMessage("単語、品詞、意味は必須です！", "error");
                return;
            }
            
            // WordIdの自動採番または重複チェック
            if (isNaN(wordId) || wordId <= 0) {
                wordId = getNextAvailableWordId();
            } else {
                if (dictionaryData.some(item => item.wordId === wordId)) {
                    displayMessage(`単語識別番号 ${wordId} は既に使われています。別の番号を入力するか、空欄にしてください。`, "error");
                    return;
                }
            }

            const newWord = {
                wordId: wordId,
                word: word,
                partOfSpeech: partOfSpeech,
                meaning: meaning,
                examples: examples,
                usage: usage,
                timestamp: new Date().toISOString()
            };
            dictionaryData.push(newWord);
            saveData();
            
            // UIをクリア
            wordIdInput.value = '';
            wordInput.value = '';
            partOfSpeechSelect.value = '';
            newPartOfSpeechInput.value = '';
            newPartOfSpeechContainer.classList.add('hidden');
            meaningInput.value = '';
            exampleInput.value = '';
            usageInput.value = '';

            renderWords();
            displayMessage("単語が追加されました！", "success");
        };

        // 単語をレンダリングする関数
        const renderWords = () => {
            const currentSearchQuery = searchInput.value.toLowerCase().trim();
            const currentPartOfSpeechFilter = partOfSpeechFilter.value;
            const currentSortOption = sortOption.value;

            let filteredWords = dictionaryData.filter(wordData => {
                const matchesSearch = currentSearchQuery === '' || wordData.word.toLowerCase().includes(currentSearchQuery);
                const matchesFilter = currentPartOfSpeechFilter === 'すべて' || wordData.partOfSpeech === currentPartOfSpeechFilter;
                return matchesSearch && matchesFilter;
            });

            filteredWords.sort((a, b) => {
                switch (currentSortOption) {
                    case 'timestamp_asc':
                        return new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime();
                    case 'timestamp_desc':
                        return new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime();
                    case 'wordId_asc':
                        return (a.wordId || Infinity) - (b.wordId || Infinity);
                    case 'wordId_desc':
                        return (b.wordId || Infinity) - (a.wordId || Infinity);
                    case 'word_asc':
                        return (a.word || '').localeCompare(b.word || '', 'ja', { sensitivity: 'base' });
                    case 'word_desc':
                        return (b.word || '').localeCompare(a.word || '', 'ja', { sensitivity: 'base' });
                    default:
                        return 0;
                }
            });

            wordListDiv.innerHTML = '';
            
            if (displayMode === 'small') {
                wordListDiv.className = 'flex flex-wrap gap-2 justify-center sm:justify-start';
            } else {
                wordListDiv.className = 'space-y-4';
            }

            if (filteredWords.length === 0) {
                loadingMessage.textContent = "条件に一致する単語は見つかりませんでした。";
                loadingMessage.style.display = 'block';
                wordListDiv.appendChild(loadingMessage);
            } else {
                loadingMessage.style.display = 'none';
                filteredWords.forEach((data) => {
                    const displayWordId = data.wordId !== undefined ? `#${data.wordId}` : '';
                    const wordCard = document.createElement('div');
                    
                    const wordContent = `<span class="word-font">${data.word}</span>`;

                    if (displayMode === 'large') {
                        wordCard.className = 'bg-gray-50 p-4 rounded-lg shadow-sm border border-gray-200 flex flex-col sm:flex-row justify-between items-start sm:items-center relative cursor-pointer';
                        wordCard.innerHTML = `
                            <div>
                                <h3 class="text-xl font-semibold text-gray-900">${displayWordId} ${wordContent} <span class="text-sm text-gray-500 ml-2">(${data.partOfSpeech || '品詞不明'})</span></h3>
                                <p class="text-gray-700 mt-1 whitespace-pre-wrap">${data.meaning}</p>
                            </div>
                            <div class="sm:ml-4 mt-3 sm:mt-0 flex space-x-2">
                                <button data-id="${data.wordId}" data-action="delete" class="delete-btn bg-red-500 hover:bg-red-600 text-white text-sm font-bold py-1 px-3 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:-translate-y-0.5">削除</button>
                            </div>
                        `;
                    } else { // compact mode
                        wordCard.className = 'bg-gray-50 p-2 rounded-lg shadow-sm border border-gray-200 flex flex-col justify-between items-start text-sm overflow-hidden w-36';
                        wordCard.innerHTML = `
                            <div class="flex items-center space-x-1 w-full">
                                <span class="text-xs text-gray-500 font-semibold flex-shrink-0">${displayWordId}</span>
                                <h3 class="flex-grow font-semibold text-gray-900 truncate"><span class="word-font text-base">${data.word}</span></h3>
                            </div>
                            <div class="flex justify-end mt-1 space-x-1 w-full">
                                <button data-id="${data.wordId}" data-action="delete" class="delete-btn bg-red-500 hover:bg-red-600 text-white text-xs py-0.5 px-1 rounded-lg">削除</button>
                            </div>
                        `;
                    }
                    wordCard.addEventListener('click', (e) => {
                        if (e.target.dataset.action === 'delete') {
                            return;
                        }
                        showWordDetail(data.wordId);
                    });
                    wordListDiv.appendChild(wordCard);
                });
            }
            addEventListenersToDeleteButtons();
        };
        
        // 削除ボタンにイベントリスナーを追加
        const addEventListenersToDeleteButtons = () => {
            document.querySelectorAll('.delete-btn').forEach(button => {
                button.removeEventListener('click', handleDeleteButtonClick); // 重複登録防止
                button.addEventListener('click', handleDeleteButtonClick);
            });
        };
        
        // 削除ボタンクリック時の共通ハンドラ
        const handleDeleteButtonClick = (e) => {
            e.stopPropagation();
            deleteWord(e.target.dataset.id);
        };
        
        // 単語を削除する関数
        const deleteWord = (wordId) => {
            const confirmModal = document.createElement('div');
            confirmModal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center p-4 z-50';
            confirmModal.innerHTML = `
                <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-sm text-center">
                    <p class="text-lg font-semibold mb-4">この単語を本当に削除しますか？</p>
                    <div class="flex justify-center space-x-4">
                        <button id="cancelDelete" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg">キャンセル</button>
                        <button id="confirmDelete" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg">削除</button>
                    </div>
                </div>
            `;
            document.body.appendChild(confirmModal);

            document.getElementById('confirmDelete').onclick = () => {
                confirmModal.remove();
                dictionaryData = dictionaryData.filter(item => item.wordId !== parseInt(wordId));
                saveData();
                renderWords();
                displayMessage("単語が削除されました。", "success");
            };

            document.getElementById('cancelDelete').onclick = () => {
                confirmModal.remove();
            };
        };

        const renderWithCustomFont = (text) => {
            if (!text || importedFontName === null) {
                return text;
            }
            // `{{...}}`で囲まれた部分を抽出
            const regex = /\{\{([^{}]+)\}\}/g;
            let result = text;
            let matches = result.match(regex);
            if (!matches) {
                return `<span class="word-font">${text}</span>`;
            }

            matches.forEach(match => {
                const content = match.substring(2, match.length - 2);
                const replacement = `<span class="word-font">${content}</span>`;
                result = result.replace(match, replacement);
            });
            return result;
        };

        const applyFontToElement = (element, content) => {
            element.innerHTML = renderWithCustomFont(content);
        };

        // 単語詳細を表示する関数
        const showWordDetail = (wordId) => {
            const wordData = dictionaryData.find(item => item.wordId === parseInt(wordId));
            if (!wordData) {
                displayMessage("単語の詳細が見つかりません。", "error");
                return;
            }

            currentWordDetailId = wordId;

            applyFontToElement(detailWordTitle, wordData.word);
            detailWordId.textContent = wordData.wordId !== undefined ? wordData.wordId : 'N/A';
            detailPartOfSpeech.textContent = wordData.partOfSpeech || '品詞不明';
            detailMeaning.textContent = wordData.meaning || '';
            detailUsage.textContent = wordData.usage || '';

            // 例文の表示
            if (wordData.examples && wordData.examples.length > 0) {
                detailExamples.innerHTML = wordData.examples.map(ex => `<p>${renderWithCustomFont(ex)}</p>`).join('');
            } else {
                detailExamples.textContent = '例文なし';
            }

            // 関連語の表示
            if (wordData.synonyms && wordData.synonyms.length > 0) {
                detailSynonyms.textContent = wordData.synonyms.join('、 ');
            } else {
                detailSynonyms.textContent = '関連語なし';
            }

            detailEditButton.onclick = () => editWord(wordId);
            detailDeleteButton.onclick = () => {
                deleteWord(wordId);
                goBackToList();
            };

            listView.classList.add('hidden');
            detailView.classList.remove('hidden');
        };

        // リスト表示に戻る関数
        const goBackToList = () => {
            detailView.classList.add('hidden');
            listView.classList.remove('hidden');
            currentWordDetailId = null;
            renderWords();
        };
        
        // 単語を編集する関数 (モーダル表示)
        const editWord = (wordId) => {
            const currentData = dictionaryData.find(item => item.wordId === parseInt(wordId));
            if (!currentData) {
                displayMessage("編集する単語が見つかりません。", "error");
                return;
            }

            const editModal = document.createElement('div');
            editModal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center p-4 z-50';
            editModal.innerHTML = `
                <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
                    <h2 class="text-2xl font-bold mb-4">単語を編集</h2>
                    <div class="mb-4">
                        <label for="editWordId" class="block text-gray-700 text-sm font-bold mb-2">単語識別番号:</label>
                        <input type="number" id="editWordId" value="${currentData.wordId || ''}" disabled
                               class="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight bg-gray-100 cursor-not-allowed">
                    </div>
                    <div class="mb-4">
                        <label for="editWord" class="block text-gray-700 text-sm font-bold mb-2">単語:</label>
                        <input type="text" id="editWord" value="${currentData.word}"
                               class="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </div>
                    <div class="mb-4">
                        <label for="editPartOfSpeechSelect" class="block text-gray-700 text-sm font-bold mb-2">品詞:</label>
                        <select id="editPartOfSpeechSelect"
                                class="shadow border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500">
                        </select>
                        <div id="editNewPartOfSpeechContainer" class="mt-2 hidden">
                            <label for="editNewPartOfSpeechInput" class="block text-gray-700 text-sm font-bold mb-2">新しい品詞を入力:</label>
                            <input type="text" id="editNewPartOfSpeechInput" placeholder="例: 擬音語"
                                   class="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500">
                        </div>
                    </div>
                    <div class="mb-6">
                        <label for="editMeaning" class="block text-gray-700 text-sm font-bold mb-2">意味:</label>
                        <textarea id="editMeaning" rows="4"
                                  class="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500">${currentData.meaning}</textarea>
                    </div>
                    <div class="mb-6">
                        <label for="editExample" class="block text-gray-700 text-sm font-bold mb-2">例文 (各行が1つの例文):</label>
                        <textarea id="editExample" rows="4"
                                  class="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500">${currentData.examples ? currentData.examples.join('\n') : ''}</textarea>
                    </div>
                    <div class="mb-6">
                        <label for="editUsage" class="block text-gray-700 text-sm font-bold mb-2">用法・詳細情報:</label>
                        <textarea id="editUsage" rows="4"
                                  class="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500">${currentData.usage || ''}</textarea>
                    </div>
                    <div class="flex justify-end space-x-4">
                        <button id="cancelEdit" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg">キャンセル</button>
                        <button id="saveEdit" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">保存</button>
                    </div>
                </div>
            `;
            document.body.appendChild(editModal);

            const editPartOfSpeechSelect = editModal.querySelector('#editPartOfSpeechSelect');
            const editNewPartOfSpeechContainer = editModal.querySelector('#editNewPartOfSpeechContainer');
            const editNewPartOfSpeechInput = editModal.querySelector('#editNewPartOfSpeechInput');

            populateSelectElement(editPartOfSpeechSelect, allAvailablePartsOfSpeech, 'その他', currentData.partOfSpeech, false);
            
            editPartOfSpeechSelect.addEventListener('change', () => {
                if (editPartOfSpeechSelect.value === 'その他') {
                    editNewPartOfSpeechContainer.classList.remove('hidden');
                } else {
                    editNewPartOfSpeechContainer.classList.add('hidden');
                    editNewPartOfSpeechInput.value = '';
                }
            });

            if (editPartOfSpeechSelect.value === 'その他' && currentData.partOfSpeech && !allAvailablePartsOfSpeech.includes(currentData.partOfSpeech)) {
                editNewPartOfSpeechContainer.classList.remove('hidden');
                editNewPartOfSpeechInput.value = currentData.partOfSpeech;
            }

            document.getElementById('saveEdit').onclick = () => {
                const newWord = editModal.querySelector('#editWord').value.trim();
                let newPartOfSpeech = editPartOfSpeechSelect.value;
                const newMeaning = editModal.querySelector('#editMeaning').value.trim();
                const newExamples = editModal.querySelector('#editExample').value.trim().split('\n').filter(line => line.trim() !== '');
                const newUsage = editModal.querySelector('#editUsage').value.trim();

                if (newPartOfSpeech === 'その他') {
                    const customPos = editNewPartOfSpeechInput.value.trim();
                    if (customPos === '') {
                        displayMessage("新しい品詞を入力してください！", "error");
                        return;
                    }
                    newPartOfSpeech = customPos;
                    if (!customPartsOfSpeech.includes(newPos)) {
                        customPartsOfSpeech.push(newPos);
                        updateAllAvailablePartsOfSpeech();
                        populatePartOfSpeechDropdowns();
                    }
                }

                if (newWord === '' || newMeaning === '' || newPartOfSpeech === '' || newPartOfSpeech === '選択してください') {
                    displayMessage("単語、品詞、意味は必須です！", "error");
                    return;
                }

                // 更新
                const wordIndex = dictionaryData.findIndex(item => item.wordId === parseInt(wordId));
                if (wordIndex !== -1) {
                    dictionaryData[wordIndex].word = newWord;
                    dictionaryData[wordIndex].partOfSpeech = newPartOfSpeech;
                    dictionaryData[wordIndex].meaning = newMeaning;
                    dictionaryData[wordIndex].examples = newExamples;
                    dictionaryData[wordIndex].usage = newUsage;
                }
                saveData();
                displayMessage("単語が更新されました！", "success");
                editModal.remove();
                if (currentWordDetailId === wordId) {
                    showWordDetail(wordId);
                }
            };

            document.getElementById('cancelEdit').onclick = () => {
                editModal.remove();
            };
        };
        
        // UIメッセージ表示関数（alertの代替）
        const displayMessage = (message, type = "info") => {
            const messageBox = document.createElement('div');
            let bgColor = 'bg-blue-500';
            if (type === 'success') bgColor = 'bg-green-500';
            if (type === 'error') bgColor = 'bg-red-500';

            messageBox.className = `fixed bottom-4 right-4 ${bgColor} ${bgColor === 'bg-blue-500' ? 'text-white' : 'text-white'} px-4 py-2 rounded-lg shadow-lg z-50`;
            messageBox.textContent = message;
            document.body.appendChild(messageBox);

            setTimeout(() => {
                messageBox.remove();
            }, 3000);
        };

        // --- インポート/エクスポート機能 ---
        
        // CSV形式でエスケープ処理を行うヘルパー関数
        const escapeCsv = (value) => {
            if (value === null || value === undefined) return '';
            let s = String(value);
            s = s.replace(/[\r\n]+/g, ' '); // 改行はスペースに置換
            if (s.includes(',') || s.includes('"')) {
                s = s.replace(/"/g, '""');
                return `"${s}"`;
            }
            return s;
        };

        // 辞書データをTXT/CSVファイルとしてエクスポートする関数
        const exportDictionary = () => {
            if (dictionaryData.length === 0) {
                displayMessage("エクスポートする単語がありません。", "info");
                return;
            }
            
            let exportText = "Word ID,Word,Part of Speech,Meaning,Examples,Usage\n"; // Usage列を追加

            dictionaryData.forEach((data) => {
                const wordId = escapeCsv(data.wordId !== undefined ? data.wordId : '');
                const word = escapeCsv(data.word);
                const partOfSpeech = escapeCsv(data.partOfSpeech);
                const meaning = escapeCsv(data.meaning ? data.meaning.replace(/[\r\n]+/g, ' ') : '');
                // 例文を特定の区切り文字で結合してエスケープ
                const examples = escapeCsv(data.examples && data.examples.length > 0 ? data.examples.join(' ||| ') : '');
                const usage = escapeCsv(data.usage || '');

                exportText += `${wordId},${word},${partOfSpeech},${meaning},${examples},${usage}\n`;
            });

            const blob = new Blob([exportText], { type: 'text/csv;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `dictionary_export_${new Date().toISOString().slice(0, 10)}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            displayMessage("辞書をエクスポートしました！", "success");
        };

        // CSVパーサーの簡易実装
        const parseCsvLine = (line) => {
            const result = [];
            let inQuote = false;
            let currentField = '';
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    if (inQuote && i + 1 < line.length && line[i + 1] === '"') {
                        currentField += '"';
                        i++;
                    } else {
                        inQuote = !inQuote;
                    }
                } else if (char === ',' && !inQuote) {
                    result.push(currentField);
                    currentField = '';
                } else {
                    currentField += char;
                }
            }
            result.push(currentField);
            return result.map(field => field.trim());
        };

        // TXT/CSVファイルを読み込み、インポートオプションを表示する関数
        const handleImportFileSelect = (event) => {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                importedFileContent = e.target.result;
                importOptionsModal.classList.remove('hidden');
            };
            reader.readAsText(file);
        };

        // 実際に辞書をインポートする処理 (モードによって分岐)
        const processImport = (mode) => {
            importOptionsModal.classList.add('hidden');
            if (!importedFileContent) {
                displayMessage("インポートするファイルの内容がありません。", "error");
                return;
            }

            const text = importedFileContent;
            const lines = text.split('\n').filter(line => line.trim() !== '');

            if (lines.length === 0) {
                displayMessage("インポートするデータが見つかりません。", "info");
                importedFileContent = null;
                importFile.value = '';
                return;
            }

            let startIndex = 0;
            const firstLine = lines[0].toLowerCase();
            if (firstLine.includes('word id,') && firstLine.includes('word,') && firstLine.includes('part of speech,') && firstLine.includes('meaning')) {
                startIndex = 1;
            }

            const wordsToImport = [];
            const newCustomPartsToSave = new Set();
            for (let i = startIndex; i < lines.length; i++) {
                const line = lines[i];
                const parsedFields = parseCsvLine(line);

                let currentWordId, currentWord, currentPartOfSpeech, currentMeaning, currentExamples, currentUsage;
                
                if (parsedFields.length >= 6) {
                    currentWordId = parsedFields[0] ? parseInt(parsedFields[0]) : NaN;
                    currentWord = parsedFields[1];
                    currentPartOfSpeech = parsedFields[2];
                    currentMeaning = parsedFields[3];
                    currentExamples = parsedFields[4].split(' ||| ').filter(ex => ex.trim() !== '');
                    currentUsage = parsedFields[5];
                } else if (parsedFields.length >= 5) {
                    currentWordId = parsedFields[0] ? parseInt(parsedFields[0]) : NaN;
                    currentWord = parsedFields[1];
                    currentPartOfSpeech = parsedFields[2];
                    currentMeaning = parsedFields[3];
                    currentExamples = parsedFields[4].split(' ||| ').filter(ex => ex.trim() !== '');
                    currentUsage = '';
                } else if (parsedFields.length >= 4) {
                    currentWordId = parsedFields[0] ? parseInt(parsedFields[0]) : NaN;
                    currentWord = parsedFields[1];
                    currentPartOfSpeech = parsedFields[2];
                    currentMeaning = parsedFields[3];
                    currentExamples = [];
                    currentUsage = '';
                } else if (parsedFields.length >= 3) {
                    currentWordId = NaN;
                    currentWord = parsedFields[0];
                    currentPartOfSpeech = parsedFields[1];
                    currentMeaning = parsedFields[2];
                    currentExamples = [];
                    currentUsage = '';
                } else {
                    console.warn("不正な形式の行をスキップしました:", line);
                    continue;
                }

                if (currentWord && currentMeaning) {
                    wordsToImport.push({
                        wordId: currentWordId,
                        word: currentWord,
                        partOfSpeech: currentPartOfSpeech,
                        meaning: currentMeaning,
                        examples: currentExamples,
                        usage: currentUsage,
                        timestamp: new Date().toISOString()
                    });
                    if (currentPartOfSpeech && !predefinedPartsOfSpeech.includes(currentPartOfSpeech) && !customPartsOfSpeech.includes(currentPartOfSpeech)) {
                        newCustomPartsToSave.add(currentPartOfSpeech);
                    }
                }
            }

            if (mode === 'new') {
                dictionaryData = [];
                customPartsOfSpeech = Array.from(newCustomPartsToSave);
            } else { // append mode
                for (const newPos of newCustomPartsToSave) {
                    if (!customPartsOfSpeech.includes(newPos)) {
                        customPartsOfSpeech.push(newPos);
                    }
                }
            }

            const existingKeys = new Set(dictionaryData.map(item => `${item.word}|${item.partOfSpeech}|${item.meaning}`));
            let newIdCounter = getNextAvailableWordId();
            let importedCount = 0;
            let skippedDuplicates = 0;
            let skippedInvalidIds = 0;

            for (const newEntry of wordsToImport) {
                const key = `${newEntry.word}|${newEntry.partOfSpeech}|${newEntry.meaning}`;
                if (mode === 'append' && existingKeys.has(key)) {
                    skippedDuplicates++;
                    continue;
                }
                
                let importWordId = newEntry.wordId;
                if (isNaN(importWordId) || importWordId <= 0 || dictionaryData.some(item => item.wordId === importWordId)) {
                    importWordId = newIdCounter;
                    newIdCounter++;
                    if (newEntry.wordId && !isNaN(newEntry.wordId) && newEntry.wordId > 0) {
                        skippedInvalidIds++;
                    }
                }
                newEntry.wordId = importWordId;
                dictionaryData.push(newEntry);
                existingKeys.add(key);
                importedCount++;
            }
            
            saveData();
            updateAllAvailablePartsOfSpeech();
            populatePartOfSpeechDropdowns();
            renderWords();

            let message = `${importedCount}個の単語をインポートしました！`;
            if (skippedDuplicates > 0) {
                message += ` (${skippedDuplicates}個の重複する単語はスキップされました。)`;
            }
            if (skippedInvalidIds > 0) {
                message += ` (${skippedInvalidIds}個の無効または重複するIDを持つ単語はスキップされました。)`;
            }
            displayMessage(message, "success");

            importedFileContent = null;
            importFile.value = '';
        };

        // --- Gemini API 連携機能 ---

        const callGeminiApi = async (prompt) => {
            loadingModal.classList.remove('hidden');
            const apiKey = ""; 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
            };

            let response;
            try {
                response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`API Error: ${response.status}`);
                }

                const result = await response.json();
                const text = result?.candidates?.[0]?.content?.parts?.[0]?.text;
                loadingModal.classList.add('hidden');
                return text;

            } catch (error) {
                loadingModal.classList.add('hidden');
                console.error("Gemini API Error:", error);
                displayMessage("生成中にエラーが発生しました。もう一度お試しください。", "error");
                return null;
            }
        };

        const generateSynonyms = async (word, meaning, partOfSpeech) => {
            const prompt = `「${word}」という単語の類義語を3つ、コンマ区切りで日本語でリストアップしてください。文脈は「${meaning}」、品詞は「${partOfSpeech}」です。`;
            const result = await callGeminiApi(prompt);
            return result ? result.split(',').map(s => s.trim()) : null;
        };

        const generateExamples = async (word, meaning, partOfSpeech) => {
            const prompt = `「${word}」という単語の例文を3つ、日本語で作成してください。文脈は「${meaning}」、品詞は「${partOfSpeech}」です。各例文は新しい行で区切ってください。`;
            const result = await callGeminiApi(prompt);
            return result ? result.split('\n').map(s => s.trim()).filter(s => s) : null;
        };

        const generateUsage = async (word, meaning, partOfSpeech) => {
            const prompt = `「${word}」という単語の「用法・詳細情報」を日本語で作成してください。意味は「${meaning}」、品詞は「${partOfSpeech}」です。ニュアンスや文化的背景、よく使われる場面などを簡潔にまとめてください。`;
            const result = await callGeminiApi(prompt);
            return result ? result.trim() : null;
        };

        // イベントリスナー
        addWordButton.addEventListener('click', addWord);
        partOfSpeechSelect.addEventListener('change', () => {
            if (partOfSpeechSelect.value === 'その他') {
                newPartOfSpeechContainer.classList.remove('hidden');
            } else {
                newPartOfSpeechContainer.classList.add('hidden');
                newPartOfSpeechInput.value = '';
            }
        });
        searchInput.addEventListener('input', renderWords);
        partOfSpeechFilter.addEventListener('change', renderWords);
        clearFiltersButton.addEventListener('click', () => {
            searchInput.value = '';
            partOfSpeechFilter.value = 'すべて';
            sortOption.value = 'timestamp_desc';
            renderWords();
        });

        sortOption.addEventListener('change', renderWords);

        viewModeLargeButton.addEventListener('click', () => {
            displayMode = 'large';
            viewModeLargeButton.classList.add('btn-active');
            viewModeLargeButton.classList.remove('btn-inactive');
            viewModeSmallButton.classList.remove('btn-active');
            viewModeSmallButton.classList.add('btn-inactive');
            renderWords();
        });

        viewModeSmallButton.addEventListener('click', () => {
            displayMode = 'small';
            viewModeSmallButton.classList.add('btn-active');
            viewModeSmallButton.classList.remove('btn-inactive');
            viewModeLargeButton.classList.remove('btn-active');
            viewModeLargeButton.classList.add('btn-inactive');
            renderWords();
        });

        exportButton.addEventListener('click', exportDictionary);
        importFile.addEventListener('change', handleImportFileSelect);

        importNewButton.addEventListener('click', () => processImport('new'));
        importAppendButton.addEventListener('click', () => processImport('append'));
        cancelImportButton.addEventListener('click', () => {
            importOptionsModal.classList.add('hidden');
            importedFileContent = null;
            importFile.value = '';
        });
        
        // フォントインポート処理
        fontFile.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const fontName = `imported-font-${Date.now()}`;
                const style = document.createElement('style');
                style.textContent = `
                    @font-face {
                        font-family: '${fontName}';
                        src: url('${e.target.result}');
                    }
                `;
                document.head.appendChild(style);
                document.documentElement.style.setProperty('--word-font', `'${fontName}'`);
                importedFontName = fontName;
                displayMessage("フォントがインポートされました！", "success");
                renderWords();
            };
            reader.readAsDataURL(file);
        });

        backToListButton.addEventListener('click', goBackToList);

        /*generateSynonymsButton.addEventListener('click', async () => {
            if (!currentWordDetailId) return;
            const wordData = dictionaryData.find(item => item.wordId === parseInt(currentWordDetailId));
            if (!wordData) return;

            const synonyms = await generateSynonyms(wordData.word, wordData.meaning, wordData.partOfSpeech);
            if (synonyms) {
                detailSynonyms.textContent = synonyms.join('、 ');
                wordData.synonyms = synonyms;
                saveData();
                displayMessage("類義語が生成されました！", "success");
            }
        });

        generateExamplesButton.addEventListener('click', async () => {
            if (!currentWordDetailId) return;
            const wordData = dictionaryData.find(item => item.wordId === parseInt(currentWordDetailId));
            if (!wordData) return;

            const examples = await generateExamples(wordData.word, wordData.meaning, wordData.partOfSpeech);
            if (examples) {
                detailExamples.innerHTML = examples.map(ex => `<p>${renderWithCustomFont(ex)}</p>`).join('');
                wordData.examples = examples;
                saveData();
                displayMessage("例文が生成されました！", "success");
            }
        });

        generateUsageButton.addEventListener('click', async () => {
            if (!currentWordDetailId) return;
            const wordData = dictionaryData.find(item => item.wordId === parseInt(currentWordDetailId));
            if (!wordData) return;
            
            const usage = await generateUsage(wordData.word, wordData.meaning, wordData.partOfSpeech);
            if (usage) {
                detailUsage.textContent = usage;
                wordData.usage = usage;
                saveData();
                displayMessage("用法・詳細情報が生成されました！", "success");
            }
        });*/

        // アプリ起動
        loadData();
    </script>
</body>
</html>
